"""Jira client for interacting with Jira API."""

import logging
import os
from typing import Dict, List, Any

from jira import JIRA, Issue

from .jira_formatter import JiraFormatter


logger = logging.getLogger(__name__)

DEFAULT_SERVER = "https://issues.redhat.com"


class JiraTool:
    """Jira API client wrapper."""

    def __init__(self, api_token: str = None, server: str = None):
        """
        Initialize Jira client.

        Args:
            api_token: Jira API token. Defaults to JIRA_API_TOKEN env var.
            server: Jira server URL. Defaults to JIRA_SERVER env var or
            issues.redhat.com.
        """
        if api_token is None:
            api_token = os.environ.get("JIRA_API_TOKEN")
            if not api_token:
                raise ValueError("JIRA_API_TOKEN environment variable not set")

        if server is None:
            server = os.environ.get("JIRA_SERVER", DEFAULT_SERVER)

        logger.debug("Connecting to Jira server: %s", server)
        self.jira_client = JIRA(server=server, token_auth=api_token)
        self._current_user = None
        self._fields_cache = None  # Lazy-loaded field metadata cache
        logger.info("Connected to Jira server: %s", server)

    def _get_fields(self) -> List[Dict]:
        """Get all fields from Jira (cached)."""
        if self._fields_cache is None:
            logger.debug("Fetching field metadata from Jira...")
            self._fields_cache = self.jira_client.fields()
            logger.debug("Cached %d fields", len(self._fields_cache))
        return self._fields_cache

    def get_current_user(self) -> str:
        """Get the username of the currently authenticated user."""
        if self._current_user is None:
            self._current_user = self.jira_client.current_user()
            logger.debug("Current user: %s", self._current_user)
        return self._current_user

    def get_fields_name_to_id(self) -> Dict[str, str]:
        """Get mapping of field name (lowercase) to jira field id."""
        return {f["name"].lower(): f["id"] for f in self._get_fields()}

    def get_fields_id_to_name(self) -> Dict[str, str]:
        """Get mapping of field id to jira field name."""
        return {f["id"]: f["name"] for f in self._get_fields()}

    def get_all_available_fields(self) -> List[str]:
        """Get list of all available jira fields by their name."""
        return [f["name"] for f in self._get_fields()]

    def get_fields_id_to_types(self) -> Dict[str, str]:
        """Get mapping of field id to jira field type."""
        return {
            f["id"]: f.get("schema", {}).get("type", "unavailable")
            for f in self._get_fields()
        }

    def create_jira_issue(self,
                          issue_fields: Dict,
                          issue_type: str = "task"
                          ) -> Issue:
        """
        Create a new Jira issue.

        Args:
            issue_fields: Dictionary mapping field names to values.
            issue_type: Type of issue to create (e.g., 'Task', 'Bug').

        Returns:
            The newly created Jira issue object.
        """
        fields_ids_to_types = self.get_fields_id_to_types()
        fields_names_to_id = self.get_fields_name_to_id()
        issue = {}

        for field, value in issue_fields.items():
            field_id = fields_names_to_id.get(field.lower(), field)
            field_type = fields_ids_to_types.get(field_id, "any")
            formatter = getattr(JiraFormatter, field_type, JiraFormatter.any)
            issue[field_id] = formatter(value)

        issue["issuetype"] = JiraFormatter.issue_type(issue_type.capitalize())
        logger.debug("Creating issue with fields: %s", issue)
        new_issue = self.jira_client.create_issue(fields=issue)
        logger.info("Created issue: %s", new_issue.key)
        return new_issue

    def get_jira_issue(
        self,
        issue_key: str,
        all_fields: bool = False,
        field_filter: List[str] = None,
    ) -> Dict[str, Any]:
        """
        Retrieve details of a Jira issue by its key.

        Args:
            issue_key: The key of the Jira issue to retrieve.
            all_fields: If True, returns all available fields.
            field_filter: List of field names to retrieve.

        Returns:
            Dictionary containing the requested fields and their values.
        """
        fields = None

        if not all_fields:
            if field_filter is None:
                field_filter = ["assignee", "status", "description", "summary"]

            name_to_id = self.get_fields_name_to_id()
            fields = ",".join([name_to_id.get(x.lower(), x)
                              for x in field_filter])

        logger.debug("Fetching issue: %s (fields: %s)", issue_key, fields)
        issue = self.jira_client.issue(issue_key, fields=fields)
        logger.debug("Fetched issue: %s", issue_key)
        return self.issue_to_dict(issue)

    def issue_to_dict(self, issue: Issue) -> Dict[str, Any]:
        """Convert a Jira issue to a dictionary with field names as keys."""
        id_to_name = self.get_fields_id_to_name()
        return {id_to_name.get(k, k): v for k, v in issue.raw.get(
            "fields", {}).items()}

    def transition_issue_status(
        self, issue: str, transition: str, resolution: str = None
    ) -> None:
        """Transition an issue to a new status with optional resolution."""
        logger.debug(
            "Transitioning %s to %s (resolution: %s)",
            issue, transition, resolution
        )
        if resolution:
            self.jira_client.transition_issue(
                issue, transition=transition, resolution={"name": resolution}
            )
        else:
            self.jira_client.transition_issue(issue, transition=transition)
        logger.info("Transitioned %s to %s", issue, transition)

    def get_issue_link_types(self) -> List[Dict[str, str]]:
        """
        Get all available issue link types.

        Returns:
            List of dicts with 'name', 'inward', and 'outward' keys.
        """
        link_types = self.jira_client.issue_link_types()
        return [
            {
                "name": lt.name,
                "inward": lt.inward,
                "outward": lt.outward,
            }
            for lt in link_types
        ]

    def link_issue(self, link_type: str, issue_a: str, issue_b: str) -> None:
        """Create a link between two issues."""
        logger.debug("Linking %s -> %s (%s)", issue_a, issue_b, link_type)
        self.jira_client.create_issue_link(
            type=link_type, inwardIssue=issue_a, outwardIssue=issue_b
        )
        logger.info("Linked %s -> %s (%s)", issue_a, issue_b, link_type)

    def get_issue_links(
        self, issue_key: str, link_type: str = None
    ) -> List[Dict[str, Any]]:
        """
        Get links for an issue.

        Args:
            issue_key: The issue to get links for.
            link_type: Optional filter by link type name.

        Returns:
            List of dicts with 'id', 'type', 'inward_desc', 'outward_desc',
            'direction', and 'issue_key' keys.
        """
        logger.debug("Getting links for %s", issue_key)
        issue = self.jira_client.issue(issue_key, fields="issuelinks")
        links = []

        for link in issue.fields.issuelinks:
            link_type_name = link.type.name
            if link_type and link_type_name != link_type:
                continue

            link_info = {
                "id": link.id,
                "type": link_type_name,
                "inward_desc": getattr(link.type, "inward", ""),
                "outward_desc": getattr(link.type, "outward", ""),
            }

            if hasattr(link, "inwardIssue"):
                link_info["direction"] = "inward"
                link_info["issue_key"] = link.inwardIssue.key
                links.append(link_info)
            elif hasattr(link, "outwardIssue"):
                link_info["direction"] = "outward"
                link_info["issue_key"] = link.outwardIssue.key
                links.append(link_info)

        logger.debug("Found %d links for %s", len(links), issue_key)
        return links

    def delete_issue_link(self, link_id: str) -> None:
        """
        Delete an issue link by its ID.

        Args:
            link_id: The ID of the link to delete.
        """
        logger.debug("Deleting link %s", link_id)
        self.jira_client.delete_issue_link(link_id)
        logger.info("Deleted link %s", link_id)

    def add_remote_link(
        self, issue_key: str, url: str, title: str = None
    ) -> None:
        """
        Add a remote/external link to an issue.

        Args:
            issue_key: The issue to add the link to.
            url: The URL of the external resource.
            title: Optional title for the link (defaults to URL).
        """
        if title is None:
            title = url
        logger.debug("Adding remote link to %s: %s", issue_key, url)
        self.jira_client.add_remote_link(
            issue_key,
            destination={"url": url, "title": title},
        )
        logger.info("Added remote link to %s: %s", issue_key, title)

    def add_issue_comment(self, issue: str, comment: str) -> None:
        """Add a comment to an issue."""
        logger.debug("Adding comment to %s", issue)
        self.jira_client.add_comment(issue, comment)
        logger.debug("Added comment to %s", issue)

    def search_issues(
        self, jql: str, fields: List[str] = None, max_results: int = 50
    ) -> List[Issue]:
        """
        Search for issues using JQL.

        Args:
            jql: JQL query string.
            fields: List of field names to retrieve.
            max_results: Maximum number of results to return.

        Returns:
            List of matching Jira issues.
        """
        logger.debug("Searching issues with JQL: %s", jql)
        field_ids = None
        if fields:
            name_to_id = self.get_fields_name_to_id()
            field_ids = [name_to_id.get(f.lower(), f) for f in fields]

        issues = self.jira_client.search_issues(
            jql, fields=field_ids, maxResults=max_results
        )
        logger.debug("Found %d issues", len(issues))
        return issues

    def search_issues_as_dicts(
        self, jql: str, fields: List[str], max_results: int = 1000
    ) -> List[Dict[str, Any]]:
        """
        Search for issues and return as dictionaries with field names.

        This is more efficient than search_issues + get_jira_issue loop
        as it fetches all data in a single request.

        Args:
            jql: JQL query string.
            fields: List of field names to retrieve.
            max_results: Maximum number of results to return.

        Returns:
            List of dicts with 'key' and requested fields.
        """
        issues = self.search_issues(
            jql, fields=fields, max_results=max_results)
        result = []
        for issue in issues:
            issue_dict = self.issue_to_dict(issue)
            issue_dict["key"] = issue.key
            result.append(issue_dict)
        return result

    def add_label(self, issue_key: str, label: str) -> None:
        """
        Add a label to an issue.

        Args:
            issue_key: The issue to update.
            label: The label to add.
        """
        logger.debug("Adding label '%s' to %s", label, issue_key)
        issue = self.jira_client.issue(issue_key)
        existing_labels = issue.fields.labels or []
        if label not in existing_labels:
            issue.update(fields={"labels": existing_labels + [label]})
            logger.info("Added label '%s' to %s", label, issue_key)
        else:
            logger.debug("Label '%s' already exists on %s", label, issue_key)

    def remove_label(self, issue_key: str, label: str) -> None:
        """
        Remove a label from an issue.

        Args:
            issue_key: The issue to update.
            label: The label to remove.
        """
        logger.debug("Removing label '%s' from %s", label, issue_key)
        issue = self.jira_client.issue(issue_key)
        existing_labels = issue.fields.labels or []
        if label in existing_labels:
            new_labels = [l for l in existing_labels if l != label]
            issue.update(fields={"labels": new_labels})
            logger.info("Removed label '%s' from %s", label, issue_key)
        else:
            logger.debug("Label '%s' not found on %s", label, issue_key)

    def update_issue(self, issue_key: str, fields: Dict[str, Any]) -> None:
        """
        Update fields on an issue.

        Args:
            issue_key: The issue to update.
            fields: Dictionary of field names to values.
        """
        if not fields:
            return

        logger.debug("Updating %s with fields: %s",
                     issue_key, list(fields.keys()))
        issue = self.jira_client.issue(issue_key)

        # Format fields using the same logic as create_jira_issue
        fields_ids_to_types = self.get_fields_id_to_types()
        fields_names_to_id = self.get_fields_name_to_id()
        formatted = {}

        for field, value in fields.items():
            field_id = fields_names_to_id.get(field.lower(), field)
            field_type = fields_ids_to_types.get(field_id, "any")
            formatter = getattr(JiraFormatter, field_type, JiraFormatter.any)
            formatted[field_id] = formatter(value)

        issue.update(fields=formatted)
        logger.info("Updated %s: %s", issue_key, list(fields.keys()))

    def get_field_allowed_values(
        self, project_key: str, issue_type_name: str, field_name: str
    ) -> List[str]:
        """
        Get allowed values for a field in a project/issue type context.

        Args:
            project_key: The project key (e.g., 'OCPBUGS').
            issue_type_name: The issue type name (e.g., 'Bug').
            field_name: The field name (e.g., 'Target Version').

        Returns:
            List of allowed value names for the field.
        """
        logger.debug(
            "Fetching allowed values for field '%s' in %s/%s",
            field_name,
            project_key,
            issue_type_name,
        )

        field_name_lower = field_name.lower()
        name_to_id = self.get_fields_name_to_id()
        field_id = name_to_id.get(field_name_lower)

        if not field_id:
            logger.warning("Field '%s' not found", field_name)
            return []

        # Get issue type ID from project
        issue_types = self.jira_client.project_issue_types(project_key)
        issue_type_id = None
        for it in issue_types:
            if it.name.lower() == issue_type_name.lower():
                issue_type_id = it.id
                break

        if not issue_type_id:
            logger.warning(
                "Issue type '%s' not found in project %s",
                issue_type_name, project_key
            )
            return []

        # Get fields for this issue type
        fields_meta = self.jira_client.project_issue_fields(
            project_key, issue_type_id)

        allowed_values = []
        for field_meta in fields_meta:
            if field_meta.fieldId == field_id:
                for value in field_meta.allowedValues or []:
                    name = getattr(value, "name", None) or getattr(
                        value, "value", None)
                    if name:
                        allowed_values.append(name)
                break

        logger.debug(
            "Found %d allowed values for '%s'", len(allowed_values), field_name
        )
        return allowed_values
