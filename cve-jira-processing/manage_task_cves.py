#!/usr/bin/env python3
"""Close all CVE Vulnerabilities linked to a task."""

import argparse
import logging
import sys

from lib.jira_client import JiraTool

logger = logging.getLogger(__name__)

DEFAULT_RESOLUTION = "Done"
DEFAULT_STATUS = "Closed"


def get_linked_issues(
    client: JiraTool,
    task_key: str,
    issue_type_filter: str = None,
) -> list[dict]:
    """
    Get issues linked to a task.

    Finds issues linked via "is caused by" (Causality) or
    "is related to" (Relates) relationships.

    Args:
        client: Jira client.
        task_key: The task issue key.
        issue_type_filter: Filter by issue type ("Vulnerability", "Bug", or
            None for all).

    Returns:
        List of dicts with 'key', 'summary', 'status', 'resolution', 'type'
        for each linked issue.
    """
    issue_keys = []

    # Get "is caused by" links (Causality) - used for CVEs
    causality_links = client.get_issue_links(task_key, link_type="Causality")
    for link in causality_links:
        if link.get("direction") == "inward":
            issue_keys.append(link.get("issue_key"))

    # Get "is related to" links (Related) - used for bugs
    relates_links = client.get_issue_links(task_key, link_type="Related")
    for link in relates_links:
        # Include both directions for "is related to"
        issue_keys.append(link.get("issue_key"))

    if not issue_keys:
        return []

    # Remove duplicates while preserving order
    issue_keys = list(dict.fromkeys(issue_keys))

    # Fetch details for all issues
    issues = []
    for key in issue_keys:
        try:
            issue_data = client.get_jira_issue(
                key, field_filter=["Summary", "Status",
                                   "Resolution", "Issue Type"]
            )
            issue_type = issue_data.get("Issue Type", {})
            type_name = issue_type.get("name", "") if issue_type else ""

            # Filter by issue type if specified
            if issue_type_filter and type_name != issue_type_filter:
                continue

            status = issue_data.get("Status", {})
            resolution = issue_data.get("Resolution", {})
            issues.append(
                {
                    "key": key,
                    "summary": issue_data.get("Summary", "N/A"),
                    "status": status.get("name", "N/A") if status else "N/A",
                    "resolution": resolution.get("name") if resolution else None,
                    "type": type_name,
                }
            )
        except Exception as e:
            logger.warning("Failed to fetch %s: %s", key, e)

    return issues


def get_linked_cves(client: JiraTool, task_key: str) -> list[dict]:
    """Get all CVE Vulnerabilities linked to a task."""
    return get_linked_issues(client, task_key, issue_type_filter="Vulnerability")


def update_or_transition_cve(
    client: JiraTool,
    cve_key: str,
    comment: str = None,
    status: str = None,
    resolution: str = None,
    release_note_text: str = None,
    release_note_type: str = None,
    release_note_status: str = None,
    patch_url: str = None,
    patch_title: str = None,
    no_transition: bool = False,
    dry_run: bool = False,
) -> bool:
    """
    Update fields and/or transition a CVE to a new status.

    Args:
        client: Jira client.
        cve_key: The CVE issue key.
        comment: Comment to add. Optional.
        status: Target status (e.g., "Closed", "ON_QA"). Required unless
            no_transition.
        resolution: Resolution to use (e.g., "Done", "Fixed"). Optional.
        release_note_text: Release note text to set. Optional.
        release_note_type: Release note type to set. Optional.
        release_note_status: Release note status to set. Optional.
        patch_url: URL to external patch (e.g., GitHub PR). Optional.
        patch_title: Title for the patch link. Optional.
        no_transition: If True, only update fields without transitioning.
        dry_run: If True, don't make changes.

    Returns:
        True if successful, False otherwise.
    """
    if dry_run:
        if release_note_text:
            logger.info(
                "  [DRY RUN] Would set Release Note Text: %s", release_note_text
            )
        if release_note_type:
            logger.info(
                "  [DRY RUN] Would set Release Note Type: %s", release_note_type
            )
        if release_note_status:
            logger.info(
                "  [DRY RUN] Would set Release Note Status: %s", release_note_status
            )
        if patch_url:
            logger.info(
                "  [DRY RUN] Would add patch link: %s", patch_url
            )
        if comment:
            logger.info("  [DRY RUN] Would add comment: %s", comment)
        if not no_transition and status:
            # Resolution only applies when transitioning to Closed
            effective_resolution = resolution if status.upper() == "CLOSED" else None
            res_str = (
                f" with resolution '{resolution}'"
                if effective_resolution else ""
            )
            logger.info(
                "  [DRY RUN] Would transition %s to %s%s", cve_key, status, res_str
            )
        return True

    try:
        # Set release note fields
        release_fields = {}
        if release_note_text:
            release_fields["Release Note Text"] = release_note_text
        if release_note_type:
            release_fields["Release Note Type"] = release_note_type
        if release_note_status:
            release_fields["Release Note Status"] = release_note_status

        if release_fields:
            client.update_issue(cve_key, release_fields)
            logger.info("  Updated release note fields on %s", cve_key)

        # Add patch link if provided
        if patch_url:
            client.add_remote_link(cve_key, patch_url, patch_title)
            logger.info("  Added patch link to %s", cve_key)

        # Add comment if provided
        if comment:
            client.add_issue_comment(cve_key, comment)
            logger.info("  Added comment to %s", cve_key)

        # Transition to target status (unless no_transition)
        if not no_transition and status:
            # Resolution only applies when transitioning to Closed
            effective_resolution = resolution if status.upper() == "CLOSED" else None
            client.transition_issue_status(
                cve_key, status, effective_resolution)
            res_str = (
                f" with resolution '{resolution}'"
                if effective_resolution else ""
            )
            logger.info("  Transitioned %s to %s%s", cve_key, status, res_str)

        return True
    except Exception as e:
        logger.error("  Failed to update %s: %s", cve_key, e)
        return False


def setup_logging(verbose: bool = False):
    """Configure logging."""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )


def main():
    parser = argparse.ArgumentParser(
        description="Close all CVE Vulnerabilities linked to a task"
    )
    parser.add_argument(
        "task_key", help="The task issue key (e.g., OSASINFRA-12345)")
    parser.add_argument(
        "--comment",
        "-c",
        default=None,
        help=f"Comment to add (default when closing)",
    )
    parser.add_argument(
        "--status",
        "-s",
        default=DEFAULT_STATUS,
        help=f"Target status (default: '{DEFAULT_STATUS}')",
    )
    parser.add_argument(
        "--resolution",
        "-r",
        default=DEFAULT_RESOLUTION,
        help=f"Resolution to use (default: '{DEFAULT_RESOLUTION}')",
    )
    parser.add_argument(
        "--release-note-text",
        help="Release note text to set on CVEs",
    )
    parser.add_argument(
        "--release-note-type",
        nargs="?",
        const="CVE - Common Vulnerabilities and Exposures",
        help="Release note type (default: 'CVE - Common Vulnerabilities and Exposures' if flag used without value)",
    )
    parser.add_argument(
        "--release-note-status",
        nargs="?",
        const="Proposed",
        help="Release note status (default: 'Proposed' if flag used without value)",
    )
    parser.add_argument(
        "--patch-url",
        help="URL to external patch (e.g., GitHub PR/commit)",
    )
    parser.add_argument(
        "--patch-title",
        help="Title for the patch link (default: URL)",
    )
    parser.add_argument(
        "--task-status",
        help="Transition parent task to this status (e.g., POST, Closed)",
    )
    parser.add_argument(
        "--task-resolution",
        default="Done",
        help="Resolution for parent task when closing (default: Done)",
    )
    parser.add_argument(
        "--close-task",
        action="store_true",
        help="Shortcut for --task-status Closed --task-resolution Done",
    )
    parser.add_argument(
        "--no-transition",
        action="store_true",
        help="Only update fields (release notes, patch link) without transitioning",
    )
    parser.add_argument(
        "--bugs-only",
        action="store_true",
        help="Only process Bug issues (not Vulnerabilities)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose logging"
    )
    args = parser.parse_args()

    setup_logging(args.verbose)

    client = JiraTool()

    # Determine issue type filter
    if args.bugs_only:
        issue_type_filter = "Bug"
        issue_type_label = "Bugs"
    else:
        issue_type_filter = "Vulnerability"
        issue_type_label = "CVEs"

    logger.info("Finding %s linked to %s...", issue_type_label, args.task_key)
    issues = get_linked_issues(client, args.task_key, issue_type_filter)

    if not issues:
        logger.info("No %s found linked to %s",
                    issue_type_label, args.task_key)
        return

    # Filter to only open issues
    open_cves = [c for c in issues if c["status"] != "Closed"]
    closed_cves = [c for c in issues if c["status"] == "Closed"]

    logger.info(
        "Found %d %s linked to %s (%d open, %d already closed)",
        len(issues),
        issue_type_label,
        args.task_key,
        len(open_cves),
        len(closed_cves),
    )

    if closed_cves:
        logger.info("")
        logger.info("Already closed:")
        for cve in closed_cves:
            logger.info(
                "  %s [%s] - %s", cve["key"], cve["resolution"] or "N/A", cve["summary"]
            )

    if not open_cves:
        logger.info("No open %s to process", issue_type_label)
        return

    logger.info("")
    if args.no_transition:
        logger.info("%s to update:", issue_type_label)
    else:
        logger.info("%s to transition:", issue_type_label)
    for cve in open_cves:
        logger.info("  %s [%s] - %s", cve["key"],
                    cve["status"], cve["summary"])

    logger.info("")
    if args.no_transition:
        if args.dry_run:
            logger.info("[DRY RUN] Would update %d %s",
                        len(open_cves), issue_type_label)
        else:
            logger.info("Updating %d %s...", len(open_cves), issue_type_label)
    else:
        if args.dry_run:
            logger.info(
                "[DRY RUN] Would transition %d %s to %s:",
                len(open_cves), issue_type_label, args.status
            )
            logger.info("  Resolution: %s", args.resolution)
            if args.comment:
                logger.info("  Comment: %s", args.comment)
        else:
            logger.info(
                "Transitioning %d %s to %s...",
                len(open_cves), issue_type_label, args.status
            )

    success = 0
    failed = 0

    for cve in open_cves:
        if update_or_transition_cve(
            client,
            cve["key"],
            comment=args.comment,
            status=args.status,
            resolution=args.resolution,
            release_note_text=args.release_note_text,
            release_note_type=args.release_note_type,
            release_note_status=args.release_note_status,
            patch_url=args.patch_url,
            patch_title=args.patch_title,
            no_transition=args.no_transition,
            dry_run=args.dry_run,
        ):
            success += 1
        else:
            failed += 1

    logger.info("")
    if args.no_transition:
        if args.dry_run:
            logger.info("[DRY RUN] Would have updated %d %s",
                        success, issue_type_label)
        else:
            logger.info("Done: %d updated, %d failed", success, failed)
    else:
        if args.dry_run:
            logger.info(
                "[DRY RUN] Would have transitioned %d %s", success, issue_type_label
            )
        else:
            logger.info("Done: %d transitioned, %d failed", success, failed)

    # Transition the parent task if requested
    task_status = args.task_status
    if args.close_task and not task_status:
        task_status = "Closed"

    if task_status:
        logger.info("")
        # Resolution only applies when closing
        task_resolution = (
            args.task_resolution if task_status.upper() == "CLOSED" else None
        )
        res_str = f" (resolution={task_resolution})" if task_resolution else ""

        if args.dry_run:
            if args.patch_url:
                logger.info(
                    "[DRY RUN] Would add patch link to task %s: %s",
                    args.task_key,
                    args.patch_url,
                )
            logger.info(
                "[DRY RUN] Would transition task %s to %s%s",
                args.task_key,
                task_status,
                res_str,
            )
        else:
            try:
                # Add patch link to task if provided
                if args.patch_url:
                    client.add_remote_link(
                        args.task_key, args.patch_url, args.patch_title
                    )
                    logger.info("Added patch link to task %s", args.task_key)

                client.transition_issue_status(
                    args.task_key, task_status, task_resolution
                )
                logger.info(
                    "Transitioned task %s to %s%s",
                    args.task_key, task_status, res_str
                )
            except Exception as e:
                logger.error(
                    "Failed to transition task %s: %s", args.task_key, e
                )
                failed += 1

    if failed > 0:
        sys.exit(1)


if __name__ == "__main__":
    main()
