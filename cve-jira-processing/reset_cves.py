#!/usr/bin/env python3
"""Remove the processed label from CVEs for configured components."""

import argparse
import logging
from pathlib import Path

import yaml

from lib.jira_client import JiraTool

logger = logging.getLogger(__name__)

# Default config file location (same directory as script)
DEFAULT_CONFIG_PATH = Path(__file__).parent / "config.yaml"


def load_config(config_path: Path) -> dict:
    """Load configuration from YAML file."""
    if not config_path.exists():
        raise FileNotFoundError(f"Config file not found: {config_path}")

    with open(config_path, "r") as f:
        config = yaml.safe_load(f)

    required_keys = ["cve_processed_label", "repo_to_component"]
    for key in required_keys:
        if key not in config:
            raise ValueError(f"Missing required config key: {key}")

    return config


def read_issues_from_file(file_path: Path) -> list[str]:
    """Read issue keys from a file (one per line)."""
    issues = []
    with open(file_path, "r") as f:
        for line in f:
            line = line.strip()
            # Skip empty lines and comments
            if line and not line.startswith("#"):
                # Handle comma-separated values on same line
                for key in line.split(","):
                    key = key.strip()
                    if key:
                        issues.append(key)
    return issues


def query_processed_cves(
    client: JiraTool,
    downstream_components: list[str],
    cve_processed_label: str,
    cve_filter: str = None,
) -> list[str]:
    """Query for all CVEs with the processed label."""
    component_conditions = " OR ".join(
        f'"Downstream Component Name" ~ "{c}"' for c in downstream_components
    )

    jql = (
        f"project = OCPBUGS AND type = Vulnerability "
        f"AND ({component_conditions}) "
        f'AND labels = "{cve_processed_label}"'
    )

    if cve_filter:
        jql += f' AND "CVE ID" ~ "{cve_filter}"'

    logger.info("Querying for processed CVEs...")
    logger.debug("JQL: %s", jql)

    issues = client.search_issues(jql, fields=["key"], max_results=1000)
    return [issue.key for issue in issues]


def remove_label(
    client: JiraTool, issue_key: str, label: str, dry_run: bool = False
) -> bool:
    """Remove a label from an issue."""
    if dry_run:
        logger.info("  [DRY RUN] Would remove label from %s", issue_key)
        return True

    try:
        client.remove_label(issue_key, label)
        logger.info("  Removed label from %s", issue_key)
        return True
    except Exception as e:
        logger.error("  Failed to remove label from %s: %s", issue_key, e)
        return False


# Link types/descriptions to remove when --remove-links is specified
# We check type name, inward description, and outward description
LINK_TYPES_TO_REMOVE = {
    "Dependency",  # type name (may vary)
    "Duplicate",  # type name
    "Blocks",  # type name
    "depends on",  # outward description
    "is depended on by",  # inward description
    "duplicates",  # outward description
    "is duplicated by",  # inward description
    "blocks",  # outward description
    "is blocked by",  # inward description
}


def should_remove_link(link: dict) -> bool:
    """Check if a link should be removed based on type or descriptions."""
    return (
        link["type"] in LINK_TYPES_TO_REMOVE
        or link.get("inward_desc", "") in LINK_TYPES_TO_REMOVE
        or link.get("outward_desc", "") in LINK_TYPES_TO_REMOVE
    )


def remove_links(
    client: JiraTool, issue_key: str, dry_run: bool = False
) -> int:
    """
    Remove dependency and duplicate links from an issue.

    Returns the number of links removed.
    """
    try:
        links = client.get_issue_links(issue_key)
    except Exception as e:
        logger.error("  Failed to get links for %s: %s", issue_key, e)
        return 0

    removed = 0
    for link in links:
        if should_remove_link(link):
            if dry_run:
                logger.info(
                    "  [DRY RUN] Would remove link: %s %s %s",
                    issue_key,
                    link["type"],
                    link["issue_key"],
                )
                removed += 1
            else:
                try:
                    client.delete_issue_link(link["id"])
                    logger.info(
                        "  Removed link: %s %s %s",
                        issue_key,
                        link["type"],
                        link["issue_key"],
                    )
                    removed += 1
                except Exception as e:
                    logger.error(
                        "  Failed to remove link %s: %s", link["id"], e
                    )

    return removed


def transition_to_assigned(
    client: JiraTool, issue_key: str, dry_run: bool = False
) -> bool:
    """Transition an issue to ASSIGNED status."""
    if dry_run:
        logger.info("  [DRY RUN] Would transition %s to ASSIGNED", issue_key)
        return True

    try:
        client.transition_issue_status(issue_key, "ASSIGNED")
        logger.info("  Transitioned %s to ASSIGNED", issue_key)
        return True
    except Exception as e:
        logger.error("  Failed to transition %s: %s", issue_key, e)
        return False


def setup_logging(verbose: bool = False):
    """Configure logging."""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )


def main():
    parser = argparse.ArgumentParser(
        description="Remove processed label from CVEs for configured components"
    )
    parser.add_argument(
        "--config",
        type=Path,
        default=DEFAULT_CONFIG_PATH,
        help="Path to config file (default: config.yaml)",
    )
    parser.add_argument(
        "--cve",
        dest="cve_filter",
        metavar="CVE-ID",
        help="Process only a specific CVE (e.g., CVE-2024-1234)",
    )
    parser.add_argument(
        "-f",
        "--file",
        type=Path,
        dest="issues_file",
        help="File containing issue keys (one per line)",
    )
    parser.add_argument(
        "--remove-links",
        action="store_true",
        help="Also remove dependency and duplicate links from issues",
    )
    parser.add_argument(
        "--reassign",
        action="store_true",
        help="Transition issues back to ASSIGNED status",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose logging"
    )
    args = parser.parse_args()

    setup_logging(args.verbose)

    config = load_config(args.config)
    cve_processed_label = config["cve_processed_label"]
    repo_to_component = config["repo_to_component"]
    downstream_components = list(repo_to_component.keys())

    logger.info("Loaded config from %s", args.config)
    logger.info("Label to remove: %s", cve_processed_label)

    client = JiraTool()

    # Get issues either from file or from query
    if args.issues_file:
        if not args.issues_file.exists():
            logger.error("File not found: %s", args.issues_file)
            return
        issues = read_issues_from_file(args.issues_file)
        logger.info("Read %d issues from %s", len(issues), args.issues_file)
    else:
        logger.info("Components: %s", downstream_components)
        if args.cve_filter:
            logger.info("Filtering for CVE: %s", args.cve_filter)
        issues = query_processed_cves(
            client, downstream_components, cve_processed_label, args.cve_filter
        )

    if not issues:
        logger.info("No issues found")
        return

    logger.info("Found %d issues to process", len(issues))

    if args.dry_run:
        logger.info("[DRY RUN] Would process:")
        for issue in issues:
            logger.info("  %s", issue)

    label_success = 0
    label_failed = 0
    links_removed = 0
    transition_success = 0
    transition_failed = 0

    for issue in issues:
        logger.info("Processing %s:", issue)

        # Remove label
        if remove_label(client, issue, cve_processed_label, args.dry_run):
            label_success += 1
        else:
            label_failed += 1

        # Remove links if requested
        if args.remove_links:
            links_removed += remove_links(client, issue, args.dry_run)

        # Transition to ASSIGNED if requested
        if args.reassign:
            if transition_to_assigned(client, issue, args.dry_run):
                transition_success += 1
            else:
                transition_failed += 1

    logger.info("")
    if args.dry_run:
        logger.info("[DRY RUN] Summary:")
        logger.info("  Labels to remove: %d", label_success)
        if args.remove_links:
            logger.info("  Links to remove: %d", links_removed)
        if args.reassign:
            logger.info("  Issues to reassign: %d", transition_success)
    else:
        logger.info("Done:")
        logger.info("  Labels removed: %d succeeded, %d failed", label_success, label_failed)
        if args.remove_links:
            logger.info("  Links removed: %d", links_removed)
        if args.reassign:
            logger.info(
                "  Transitions: %d succeeded, %d failed",
                transition_success, transition_failed
            )


if __name__ == "__main__":
    main()
